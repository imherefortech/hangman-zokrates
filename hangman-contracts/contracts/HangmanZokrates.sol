// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import './BaseHangman.sol';
import './verifiers/HangmanVerifierZokrates.sol';

contract HangmanZokrates is BaseHangman {
    
    /// @notice Zokrates proof verifier
    HangmanVerifierZokrates immutable verifier;

    constructor(address _verifier) {
        verifier = HangmanVerifierZokrates(_verifier);
    }

    /**
     * @notice Creates new game. Persists hash of a secret word and the length of the word.
     * @param proof Proof generated by Zokrates
     * @param input Input for the verifier where:
     *  Elements  [0-7] - sha-256 hash of the secret word. Word can be from 3 to 16 characters long.
     *  Element     [8] - '0'. Required for creating new game, explained below.
     *  Elements [9-24] - a mask representing occurance of Element 8 in the word.
     *    For "Hello" the mask will be 0000011111111111 which proofs that the word is 5 characters long
     */
    function createGame(HangmanVerifierZokrates.Proof calldata proof, uint[25] calldata input) external {
        _createGame(input);

        if (!verifier.verifyTx(proof, input)) revert InvalidProof();
    }

    /**
     * @notice Verifies whether the letter exists in the secret word and captures letter's positions if guessed correctly. 
     * Only executed after a guess is made. Flips the turn back to the guesser.
     * @param proof Proof generated by Zokrates
     * @param input Input for the verifier where:
     *  Elements  [0-7] - sha-256 hash of the secret word. Word can be from 3 to 16 characters long.
     *  Element     [8] - a letter that was last suggested by the guesser. 
     *  Elements [9-24] - a mask representing positions of El.8 in the word. For example, for word "Hello" and letter "l" it will be 0011000000000000
     * @param gameId Game for which verification is submitted
     */
    function verifyLetter(HangmanVerifierZokrates.Proof calldata proof, uint[25] calldata input, uint gameId) external _verifierTurn(gameId) {
        _verifyLetter(input, gameId);

        if (!verifier.verifyTx(proof, input)) revert InvalidProof();
    }
}
