// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import './Verifier.sol';

contract Hangman is Verifier {
    
    /// @notice Mapping of game instances
    mapping(uint => Game) public games;
    
    /// @notice Information about the game including secret word, which turn it is, and previous user actions
    struct Game {
        /// @notice sha-256 encrypted secret word that game host picked
        uint32[8] secretWordHash;
        /// @notice Length of a word that game host picked (max: 16)
        uint8 length;
        /// @notice Indicates whether it is a turn to guess a letter or post a proof whether the previous guess is correct
        bool guesserTurn;
        /// @notice A list of attempts to guess letters that are in the word. Represented as codes of ASCII characters
        uint8[] attempts;
        /// @notice The resulting word as an array of ASCII characters. When first {length} characters of this array are set, the game ends
        uint8[16] word;
    }

    modifier _guesserTurn(uint gameId) {
        if (!games[gameId].guesserTurn) revert NotGuesserTurn();
        _;
    }

    modifier _verifierTurn(uint gameId) {
        if (games[gameId].guesserTurn) revert NotTurnToVerify();
        _;
    }

    modifier _letterNotUsed(uint gameId, uint8 letter) {
        Game memory game = games[gameId];
        for (uint i = 0; i < game.attempts.length; i++) {
            if (game.attempts[i] == letter) revert LetterWasUsed(letter);
        }
        _;
    }

    modifier _gameActive(uint gameId) {
        if (!isGameActive(gameId)) revert GameNotActive(gameId);

        _;
    }

    /**
     * @notice Creates new game. Persists hash of a secret word and the length of the word.
     * @param proof Proof generated by Zokrates
     * @param input Input for the verifier where:
     *  Elements  [0-7] - sha-256 hash of the secret word. Word can be from 3 to 16 characters long.
     *  Element     [8] - '0'. Required for creating new game, explained below.
     *  Elements [9-24] - a mask representing occurance of Element 8 in the word.
     *    For "Hello" the mask will be 0000011111111111 which proofs that the word is 5 characters long
     */
    function createGame(Proof calldata proof, uint[25] calldata input) external {
        uint gameId = uint(keccak256(abi.encodePacked(msg.sender, block.timestamp)));
        
        // Basic validation
        if (games[gameId].length > 0) revert GameAlreadyExsits(gameId);
        if (input[8] != 0) revert NotAStartGameInput(input);

        // Determine word length and validate 9-24 elements of the input. Revert if it's not consecutive 0's at the beginning followed by 1's till the end
        uint8 wordLength;
        for (uint i = 9; i < input.length; i++) {
            if (input[i] == 0 && wordLength == i - 9) {
                wordLength++;
            } else if (input[i] == 0) {
                revert InvalidWordInput(input);
            }
        }

        if (wordLength < 3) revert InvalidWordLength(wordLength);

        // Verify proof
        if (!verifyTx(proof, input)) revert InvalidProof();

        // Persist game information in storage
        for (uint i = 0; i < 8; i++) {
            // Conversion is safe as proof verification would fail if these are not u32 numbers
            games[gameId].secretWordHash[i] = uint32(input[i]);
        }
        games[gameId].length = wordLength;
        games[gameId].guesserTurn = true;

        emit GameCreated(gameId, wordLength);
    }

    /**
     * @notice Suggests a letter to check whether it's in the word. Can only try one that wasn't checked before. Flips the turn to the verifier
     * @param gameId Game for which the guess is submitted
     * @param letter Letter as an ASCII code
     */
    function guessLetter(uint gameId, uint8 letter) external _letterNotUsed(gameId, letter) _gameActive(gameId) _guesserTurn(gameId) {
        if (letter == 0) revert InvalidGuess(letter);

        Game storage game = games[gameId];

        if (!game.guesserTurn) revert NotGuesserTurn();

        game.attempts.push(letter);
        game.guesserTurn = false;
    }

    /**
     * @notice Verifies whether the letter exists in the secret word and captures letter's positions if guessed correctly. 
     * Only executed after a guess is made. Flips the turn back to the guesser.
     * @param proof Proof generated by Zokrates
     * @param input Input for the verifier where:
     *  Elements  [0-7] - sha-256 hash of the secret word. Word can be from 3 to 16 characters long.
     *  Element     [8] - a letter that was last suggested by the guesser. 
     *  Elements [9-24] - a mask representing positions of El.8 in the word. For example, for word "Hello" and letter "l" it will be 0011000000000000
     * @param gameId Game for which verification is submitted
     */
    function verifyLetter(Proof calldata proof, uint[25] calldata input, uint gameId) external _verifierTurn(gameId) {
        Game storage game = games[gameId];

        // Validate input
        checkWordHashMatches(game, input);
        if (input[8] != game.attempts[game.attempts.length - 1]) revert NotLatestGuess(game.attempts[game.attempts.length - 1], uint8(input[8]));

        // Verify proof
        if (!verifyTx(proof, input)) revert InvalidProof();

        // Store letter positions in the result if guessed correctly
        uint gameLength = game.length;
        for (uint i = 9; i < gameLength; i++) {
            if (input[i] == 1) { 
                game.word[i - 9] = uint8(input[8]);
            }
        }

        games[gameId].guesserTurn = true;

        if (!isGameActive(gameId)) {
            emit GameEnded(gameId, game.word);
        }
    }

    function checkWordHashMatches(Game memory game, uint[25] memory input) internal pure {
        for (uint i = 0; i < 8; i++) {
            if (game.secretWordHash[i] != uint32(input[i])) revert InvalidWordHash(input);
        }
    }

    function isGameActive(uint gameId) internal view returns (bool) {
        Game memory game = games[gameId];        
        bool gameActive;
        for (uint i = 0; i < game.length; i++) {
            if (game.word[i] == 0) {
                gameActive = true;
                break;
            }
        }

        return gameActive;
    }

    function gameAttempts(uint gameId) public view returns (uint8[] memory) {
        return games[gameId].attempts;
    }

    function gameWord(uint gameId) public view returns (uint8[16] memory) {
        return games[gameId].word;
    }

    event GameCreated(uint indexed gameId, uint8 wordLength);
    event GameEnded(uint indexed gameId, uint8[16] word);

    error GameAlreadyExsits(uint gameId);
    error GameNotActive(uint gameId);
    error NotAStartGameInput(uint[25] input);
    error InvalidProof();
    error InvalidWordInput(uint[25] input);
    error InvalidWordLength(uint8 wordLength);
    error NotGuesserTurn();
    error NotTurnToVerify();
    error LetterWasUsed(uint8 letter);
    error InvalidGuess(uint8 letter);
    error NotLatestGuess(uint8 latestGuess, uint8 verificationForGuess);
    error InvalidWordHash(uint[25] input);
}